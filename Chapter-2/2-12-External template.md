# 外部模板

外部模板是 C++11 对模板性能上的一个改进

## 外部变量

在多文件编译的时候，如果在 a.c 中声明了一个变量 i，而在 b.c 中借用 extern 关键字使用了它，那么在编译 a.c 生成了一个 a.o 的时候，里面会有一份该变量的内存，而 b.o 中则记录了 i 符号引用的文件的信息。
这样当链接器将两个中间文件链接成单个可执行文件的时候，文件区只有一个 i 变量的数据
反之，如果 a.o 和 b.o 都声明且定义了变量 i，那么在链接时就会报错，因为无法决定相同的符号如何处理。

## 模板函数的问题

模板函数遇到的情况和变量很类似。

假如文件 test.h 中声明一个模板函数，而文件 test1.cpp 和 test2.cpp 都使用了该模板函数：
```
// test.h
template <typename T> void func(T){}
// test1.cpp
#include"test.h"
void test1(){
    func(3);
}
// test2.cpp
#include"test.h"
void test1(){
    func(4);
}
```

编译器在编译两个文件时，会实例化两份 `func<int>(int)`，因为只是代码重复，链接器会在链接的时候删除一份重复的代码以节省空间。

如果这种编译时实例化，链接时删除的动作一旦过多，就会导致编译链接时间增加。

### 显示的实例化和外部模板声明
解决该问题的方法就是外部模板

外部模板的声明格式如下

```
extern template void func<int>(int)
```

所以上述模板代码中，修改如下
```
// test1.cpp
#include"test.h"
template void func<int>(int); // 显示地实例化
void test1(){
    func(3);
}
// test2.cpp
extern template void func<int>(int);    // 外部模板声明
#include"test.h"
void test1(){
    func(4);
}
```

这样在 test.o 的中间文件中就不会再包含一份 `func<int>(int)` 实例化

## 注意
在使用外部模板时我们需要注意以下几个问题：
1. 如果外部模板声明出现于某个编译单元，那么与之对应的显示实例化就必须出现在另一个编译单元中或者同一个编译单元的后续代码；
2. 外部模板声明不能用于一个静态函数，但是可以用于类的静态成员函数，因为静态函数没有外部链接属性，不可能在本编译单元之外出现

## 其他
1. C++11 中对 “模板的显式实例化定义、外部模板声明和使用” 与 “全局变量的定义、外部声明和使用” 的雷同
2. 相比较于外部变量声明，不使用外部模板声明并不会导致任何问题，它只是针对编译器的编译步骤和链接步骤的时间和空间做的优化。
3. 虽然模板实例化展开的开销会超出我们的估计，但是在四五十行的代码中并不需要显式地模板声明和外部模板声明，只有在项目会很大的时候，才建议进行这样的优化。




